# Software

Software é um conjunto de instruções, dados ou programas usados para operar computadores e executar tarefas específicas. Ao contrário do hardware, que descreve os aspectos físicos de um computador, software é um termo genérico usado para se referir a aplicativos, scripts e programas executados em um dispositivo. O software pode ser considerado a parte variável de um computador e o hardware a parte invariável.

Existem basicamente três tipos de Software:

- **Software de Sistema** para fornecer funções essenciais, como sistemas operacionais, gerenciamento de disco, utilitários, gerenciamento de hardware e outras necessidades operacionais. 
- **Software de Programação** para fornecer aos programadores ferramentas como editores de texto, compiladores, *linkers*, *debuggers* e outras ferramentas para criar código.
- **Software de Aplicativo** (aplicativos ou apps) para ajudar os usuários a executar tarefas. Conjuntos de produtividade de Escritório, software de gerenciamento de dados, players de mídia e programas de segurança são exemplos. Os aplicativos também se referem a aplicativos da Web e móveis, como aqueles usados para fazer compras como Amazon, socializar como o Facebook ou postar fotos como o Instagram.

Um quarto tipo possível é o **Software Incorporado** (*Embedded System Software*). O software de sistemas embarcados, como também é conhecido, é usado para controlar máquinas e dispositivos que normalmente não são considerados computadores - redes de telecomunicações, carros, robôs industriais e muito mais. Esses dispositivos e seus softwares podem ser conectados como parte da [Internet of Things](https://www.ibm.com/internet-of-things)(IoT).

## Desenvolvimento de Software

O desenvolvimento de software é conduzido principalmente por programadores, engenheiros de software e desenvolvedores de software. Essas funções interagem e se sobrepõem, e a dinâmica entre elas varia muito entre departamentos e comunidades de desenvolvimento.

No nível mais baixo de programação, o código executável consiste em instruções de linguagem de máquina suportadas por um processador individual - geralmente uma unidade central de processamento (CPU) ou uma unidade de processamento gráfico (GPU). Uma linguagem de máquina consiste em grupos de valores binários, significando instruções do processador que alteram o estado do computador do estado anterior. Por exemplo, uma instrução pode alterar o valor armazenado em um determinado local de armazenamento no computador - um efeito que não é diretamente observável pelo usuário. Uma instrução também pode chamar uma das muitas operações de entrada ou saída, por exemplo, exibindo algum texto na tela do computador; causando mudanças de estado que devem estar visíveis para o usuário. O processador executa as instruções na ordem em que são fornecidas, a menos que seja instruído a "pular" para uma instrução diferente ou seja interrompido pelo sistema operacional. 

A maioria dos softwares é escrita em linguagens de programação de alto nível. Eles são mais fáceis e mais eficientes para os programadores porque estão mais próximos das linguagens naturais do que das linguagens de máquina. Os idiomas de alto nível são traduzidos para o idioma da máquina usando um compilador ou interpretador ou uma combinação dos dois.

## Exemplos de Software

A tabela abaixo apresenta exemplos de Softwares em diferentes categorias de uso

| Software  | Exemplos |
|---|---|
| Antivirus  | AVG, Avast, Kaspersky |
| Audio/Music | iTunes, Winamp, Rhythmbox |
| Communication | Discord, Skype, Ventrilo |
| Databases  | SQLite, MySQL, PostgreSQL |
| Device Drivers  | Computer Drivers |
| Email  | Gmail, Outlook, YahooMail |
| Games  | Diablo, Warcraft, Tibia |
| Internet Browser  | Firefox, Google Chrome, Brave |
| Video Player | VLC, Windows Media Player, Celluloid |
| Operating Systems  | Ubuntu, Debian, Android, Windows |
| Photo/Graphics  | Photoshop, GIMP, Krita |
| Presentation  | PowerPoint, LibreOffice Impress |
| Programming Language  | C, C++, Javascript, Python, PHP |
| Simulation | SimCity, The Sims, Flight Simulator |
| Spreadsheet  | Microsoft Excel, LibreOffice Calc |
| Utility  | WinRar, CCleaner, ScreenCapture |
| Word Processor  | Microsoft Word, LibreOffice Writer |

## Breve Histórico

Um esboço (algoritmo) para o que teria sido o primeiro software foi escrito por Ada Lovelace no século 19, para o planejado [Analytical Engine](https://en.wikipedia.org/wiki/Analytical_Engine). Ela criou provas para mostrar como o mecanismo calcularia os [números de Bernoulli](https://en.wikipedia.org/wiki/Bernoulli_number). Por causa das provas e do algoritmo, ela é considerada a primeira programadora de computador.

A primeira teoria sobre software - antes da criação dos computadores como os conhecemos hoje - foi proposta por Alan Turing em seu ensaio "*On Computable Numbers, with an Application to the Entscheidungsproblem*".

Isso acabou levando à criação dos campos acadêmicos da ciência da computação e engenharia de software; Ambos os campos estudam o software e sua criação. A ciência da computação é o estudo teórico do computador e do software (o ensaio de Turing é um exemplo da ciência da computação), enquanto a engenharia de software é a aplicação da engenharia e o desenvolvimento de software.

Quando os primeiros computadores digitais apareceram no início dos anos 40, as instruções para fazê-los operar eram conectadas à máquina. Os profissionais rapidamente perceberam que esse design não era flexível e criaram a "arquitetura de programa armazenado", também conhecida como [arquitetura von Neumann](https://en.wikipedia.org/wiki/Von_Neumann_architecture). Assim, a divisão entre "hardware" e "software" começou com a abstração sendo usada para lidar com a complexidade da computação.

As linguagens de programação começaram a aparecer no início dos anos 50 e esse também foi outro grande passo na abstração. As principais linguagens, como [Fortran](https://en.wikipedia.org/wiki/Fortran), [ALGOL](https://en.wikipedia.org/wiki/ALGOL), [PL/I](https://en.wikipedia.org/wiki/PL/I) e [COBOL](https://en.wikipedia.org/wiki/COBOL), foram lançadas no final dos anos 1950 e 1960 para lidar com problemas científicos, algorítmicos e comerciais, respectivamente. [David Parnas](https://en.wikipedia.org/wiki/David_Parnas) introduziu o conceito-chave de [modularidade](https://en.wikipedia.org/wiki/Modularity) e [ocultação de informações](https://en.wikipedia.org/wiki/Information_hiding) em 1972 para ajudar os programadores a lidar com a crescente complexidade dos sistemas de software.

As origens do termo "engenharia de software" foram atribuídas a várias fontes. O termo "engenharia de software" apareceu em uma lista de serviços oferecidos por empresas na edição de junho de 1965 da [COMPUTERS and AUTOMATION](http://bitsavers.trailing-edge.com/pdf/computersAndAutomation/196506.pdf) e foi usado mais formalmente na edição de agosto de 1966 da Communications of the ACM (Volume 9, número 8) “carta ao Membro da ACM” pelo presidente da ACM Anthony A. Oettinger. 

Também está associado ao título de uma conferência da OTAN em 1968 pelo professor [Friedrich L. Bauer](https://en.wikipedia.org/wiki/Friedrich_L._Bauer), a primeira conferência sobre engenharia de software. Independentemente, Margaret Hamilton nomeou a disciplina "engenharia de software" durante as missões da Apollo para dar legitimidade ao que eles estavam fazendo. Na época, havia uma "crise de software". A 40ª Conferência Internacional de Engenharia de Software (ICSE 2018) comemora 50 anos de "Engenharia de Software" com as palestras das sessões plenárias de [Frederick Brooks](https://en.wikipedia.org/wiki/Frederick_Brooks) e [Margaret Hamilton](https://en.wikipedia.org/wiki/Margaret_Hamilton_(scientist)).

Em 1984, o [Software Engineering Institute](https://en.wikipedia.org/wiki/Software_Engineering_Institute)(SEI) foi estabelecido como um centro de pesquisa e desenvolvimento financiado pelo governo federal, com sede no campus da Universidade Carnegie Mellon, em Pittsburgh, Pensilvânia, Estados Unidos. Watts Humphrey fundou o SEI Software Process Program, destinado a entender e gerenciar o processo de engenharia de software. Os Níveis de Maturidade do Processo introduzidos se tornariam o CMMI-DEV (Capability Maturity Model Integration), que definiu como o governo dos EUA avalia as habilidades de uma equipe de desenvolvimento de software.

As práticas recomendadas modernas e geralmente aceitas para engenharia de software foram coletadas pelo subcomitê [ISO/IEC JTC 1/SC 7](https://en.wikipedia.org/wiki/ISO/IEC_JTC_1/SC_7) e publicadas como o [Software Engineering Body of Knowledge](https://en.wikipedia.org/wiki/Software_Engineering_Body_of_Knowledge)(SWEBOK).

## Engenharia de Software

Engenharia de software é a aplicação sistemática de abordagens de engenharia para o desenvolvimento de software.

As mais notáveis definições sobre o que é a Engenharia de Software incluem:

- "A aplicação sistemática de conhecimentos científicos e tecnológicos, métodos e experiência ao design, implementação, teste e documentação de software". — *The Bureau of Labor Statistics—IEEE Systems and software engineering*
- "A aplicação de uma abordagem sistemática, disciplinada e quantificável para o desenvolvimento, operação e manutenção de software". — *IEEE Standard Glossary of Software Engineering Terminology*
- "Uma disciplina de engenharia que se preocupa com todos os aspectos da produção de software" — *Ian Sommerville*
- "O estabelecimento e o uso de princípios sólidos de engenharia para obter software economicamente confiável e que funcione eficientemente em máquinas reais". — *Fritz Bauer*
- "Um ramo da ciência da computação que lida com o design, implementação e manutenção de programas de computador complexos". — *Merriam-Webste*

### Campos 

A Engenharia de Software pode ser dividida nos seguintes campos:

- **Software requirements**: A engenharia de requisitos trata da obtenção, análise, especificação e validação de [requisitos](https://en.wikipedia.org/wiki/Requirements) para software.
- **Software design**: O design de software trata do processo de definição da arquitetura, componentes, interfaces e outras características de um sistema ou componente. Isso também é chamado de [arquitetura de software](https://en.wikipedia.org/wiki/Software_architecture).
- **Software Development**: Desenvolvimento de software, a principal atividade de construção de software: É a combinação de programação (também conhecida como codificação), verificação, [teste de software](https://en.wikipedia.org/wiki/Software_testing) e *debugging*. Um [processo de desenvolvimento de software](https://en.wikipedia.org/wiki/Software_development_process): É a definição, implementação, avaliação, medição, gerenciamento, mudança e melhoria do próprio processo de ciclo de vida do software. Ele usa muito o [gerenciamento de configuração de software](https://en.wikipedia.org/wiki/Software_configuration_management), que trata de controlar sistematicamente as alterações na configuração e manter a integridade e a rastreabilidade da configuração e do código ao longo do ciclo de vida do sistema. Os processos modernos usam [software versioning](https://en.wikipedia.org/wiki/Software_versioning).
- **Software Testing**: É uma investigação técnica empírica realizada para fornecer às partes interessadas informações sobre a qualidade do produto ou serviço em teste, com diferentes abordagens, como [unit testing](https://en.wikipedia.org/wiki/Unit_testing) e [integration test](https://en.wikipedia.org/wiki/Integration_testing). É um aspecto essencial da qualidade do software.
- **Software Maintenance**: Manutenção de software refere-se às atividades necessárias para fornecer suporte econômico após o envio do produto de software.

### Qualidade de Software

A qualidade do software mede se o software atende a seus requisitos, que são classificados como funcionais ou não funcionais.

- Os **requisitos funcionais** identificam o que o software deve fazer. Os requisitos funcionais podem ser detalhes técnicos, manipulação e processamento de dados, cálculos ou qualquer outra função específica que especifique o que um aplicativo pretende realizar.
- Os **requisitos não funcionais**, também conhecidos como "atributos de qualidade", determinam como o sistema deve funcionar. Os requisitos não funcionais incluem portabilidade, recuperação de desastres, segurança, privacidade e usabilidade.

O *Software Testing* detecta e resolve problemas técnicos no código-fonte do software e avalia a usabilidade, desempenho, segurança e compatibilidade geral do produto para garantir que ele atenda aos seus requisitos.

As dimensões da qualidade de software incluem:

- **Acessibilidade**: O grau em que o software pode ser confortavelmente usado por diversos grupos de pessoas - incluindo indivíduos que exigem tecnologias adaptativas, como reconhecimento de voz e ampliadores de tela.
- **Compatibilidade**: A adequação do software para uso em uma variedade de ambientes, como diferentes sistemas operacionais, dispositivos e navegadores.
- **Eficiência**: A capacidade do software para ter um bom desempenho, sem desperdiçar energia, recursos, esforço, tempo ou dinheiro.
- **Funcionalidade**: A capacidade do software de executar suas funções especificadas ou desejadas.
- **Instalabilidade**: A capacidade do software de ser instalado em um ambiente especificado.
- **Localizability**: A capacidade do software ser usado em vários idiomas, fusos horários, etc.
- **Manutenção**: Com que facilidade o software pode ser modificado para adicionar recursos, melhorar recursos, corrigir bugs etc.
- **Desempenho**: Quão rápido o software executa sob uma carga específica.
- **Portabilidade**: A capacidade do software de ser facilmente transferido de um local para outro.
- **Confiabilidade**: A capacidade do software de executar uma função necessária em condições específicas por um período específico, sem erros.
- **Escalabilidade**: A medida da capacidade do software de aumentar ou diminuir o desempenho em resposta a mudanças nas demandas de processamento do software.
- **Segurança**: a capacidade do software de proteger contra acesso não autorizado, invasão de privacidade, roubo, perda de dados, etc.
- **Testabilidade**: A capacidade do software de ser facilmente testado.
- **Usabilidade**: Quão fácil é usar o software.